# DART



[TOC]



# Variable

> æ•°å­—ï¼ˆå°±åƒ Dart ä¸­çš„å…¶ä»–æ‰€æœ‰ä¸œè¥¿ä¸€æ ·ï¼‰éƒ½æ˜¯å¯¹è±¡

ç±»å‹æ¨æ–­

```dart
// å˜é‡ name çš„ç±»å‹è¢«æ¨æ–­ä¸º String
var name = 'Bob';
// æ˜¾å¼å£°æ˜
String name = 'Bob';
```

ä¸€ä¸ªå¯¹è±¡ä¸å—é™äºå•ä¸€ç±»å‹ï¼Œå¯ä»¥æŒ‡å®šä¸º `Object` ç±»å‹ï¼ˆæˆ–åœ¨å¿…è¦æ—¶ä½¿ç”¨ `dynamic`ï¼‰ã€‚

```dart
Object name = 'Bob';
```

## ç©ºå®‰å…¨

1. å¯ç©º

```dart
String? name  // Nullable type. Can be `null` or string.

String name   // Non-nullable type. Cannot be `null` but can be string.
```

2. å¿…é¡»åœ¨ä½¿ç”¨å˜é‡ä¹‹å‰å¯¹å…¶è¿›è¡Œåˆå§‹åŒ–ï¼ŒDart **ä¸ä¼šä¸ºéå¯ç©ºç±»å‹è®¾ç½®åˆå§‹å€¼**ï¼Œå®ƒå¼ºåˆ¶è¦æ±‚ä½ è®¾ç½®åˆå§‹å€¼ã€‚
3. ä½ ä¸èƒ½åœ¨å¯ç©ºç±»å‹çš„è¡¨è¾¾å¼ä¸Šè®¿é—®å±æ€§æˆ–è°ƒç”¨æ–¹æ³•ï¼ˆé™¤äº† `hashCode` æˆ– `toString()`ï¼‰

## é»˜è®¤å€¼

å…·æœ‰å¯ç©ºç±»å‹çš„æœªåˆå§‹åŒ–å˜é‡çš„åˆå§‹å€¼ä¸º `null` 

*é¡¶çº§å˜é‡å’Œç±»å˜é‡æ˜¯å»¶è¿Ÿåˆå§‹åŒ–çš„ï¼Œå®ƒä»¬ä¼šåœ¨ç¬¬ä¸€æ¬¡è¢«ä½¿ç”¨æ—¶å†åˆå§‹åŒ–*

## å»¶è¿Ÿåˆå§‹åŒ–å˜é‡

`late` ä¿®é¥°ç¬¦æœ‰ä¸¤ç§ç”¨æ³•ï¼š

- å£°æ˜ä¸€ä¸ªéç©ºå˜é‡ï¼Œä½†ä¸åœ¨å£°æ˜æ—¶åˆå§‹åŒ–ã€‚

  > é€šå¸¸ Dart çš„è¯­ä¹‰åˆ†æå¯ä»¥æ£€æµ‹éç©ºå˜é‡åœ¨ä½¿ç”¨ä¹‹å‰æ˜¯å¦è¢«èµ‹å€¼ï¼Œä½†æœ‰æ—¶ä¼šåˆ†æå¤±è´¥ã€‚å¸¸è§çš„ä¸¤ç§æƒ…å†µæ˜¯åœ¨**åˆ†æé¡¶çº§å˜é‡å’Œå®ä¾‹å˜é‡æ—¶**ï¼ŒDart é€šå¸¸æ— æ³•ç¡®å®šå®ƒä»¬æ˜¯å¦å·²è®¾å€¼ï¼Œå› æ­¤ä¸ä¼šå°è¯•åˆ†æã€‚

  ```dart
  // é¡¶çº§å˜é‡
  late int count;
  
  void main() {
    count = 1;
    print(count); // 1
  }
  ```

- å»¶è¿Ÿåˆå§‹åŒ–ä¸€ä¸ªå˜é‡

  - ï¼ˆDart æ¨æ–­ï¼‰å¯èƒ½ä¸éœ€è¦è¯¥å˜é‡ï¼Œå¹¶ä¸”åˆå§‹åŒ–å®ƒçš„å¼€é”€å¾ˆé«˜ã€‚
  - ä½ æ­£åœ¨åˆå§‹åŒ–ä¸€ä¸ªå®ä¾‹å˜é‡ï¼Œå®ƒçš„åˆå§‹åŒ–æ–¹æ³•éœ€è¦è°ƒç”¨ `this`ã€‚

  ```dart
  //åœºæ™¯1 
  // å¦‚æœ temperature å˜é‡ä»æœªè¢«ä½¿ç”¨ï¼Œåˆ™ readThermometer() è¿™ä¸ªå¼€é”€è¾ƒå¤§çš„å‡½æ•°ä¹Ÿæ°¸è¿œä¸ä¼šè¢«è°ƒç”¨ï¼š
  late String temperature = readThermometer(); // Lazily initialized.
  
  
  // åœºæ™¯2 å¯¹è±¡å°šæœªåˆå§‹åŒ– è°ƒç”¨äº†å¯¹è±¡æ–¹æ³•
  class Rectangle {
    final double width;
    final double height;
  
    // åªæœ‰åœ¨çœŸæ­£ä½¿ç”¨çš„æ—¶å€™æ‰ä¼šåˆå§‹åŒ–ï¼ˆä¸åŠ  late ä¼šå› ä¸º
    late final double area = _calculateArea();
    
    // ERROR: è¿™æ˜¯å› ä¸º _calculateArea æ˜¯ä¸€ä¸ªæœªç»‘å®šçš„å®ä¾‹æ–¹æ³•ï¼Œå®ƒéœ€è¦åœ¨å¯¹è±¡è¢«åˆ›å»ºä¹‹åæ‰èƒ½è¢«è°ƒç”¨
    // final double area = _calculateArea();
  
    Rectangle(this.width, this.height);
  
    double _calculateArea() {
      print('Calculating area...');
      return width * height;
    }
  }
  
  void main() {
    // å®ä¾‹åŒ–ä¸€ä¸ª Rectangle å¯¹è±¡
    Rectangle rect = Rectangle(10, 5);
  
    // æ­¤æ—¶ area å°šæœªè¢«è®¡ç®—ï¼Œå› ä¸ºå®ƒæ˜¯ late åˆå§‹åŒ–çš„
    print('Before accessing area');
  
    // ç¬¬ä¸€æ¬¡è®¿é—® area æ—¶æ‰ä¼šè®¡ç®—
    print('Area: ${rect.area}');
  
    // åç»­è®¿é—®ä¸å†é‡å¤è®¡ç®—
    print('Area again: ${rect.area}');
  }
  ```

  ## ç»ˆå€¼ (`final`) å’Œå¸¸é‡ (`const`)

> [å®ä¾‹å˜é‡](https://dart.cn/language/classes#instance-variables) å¯ä»¥æ˜¯ `final` ä½†ä¸èƒ½æ˜¯ `const`ã€‚

ä¸€ä¸ª final å˜é‡åªèƒ½è®¾ç½®ä¸€æ¬¡ï¼Œ`const` å˜é‡æ˜¯ç¼–è¯‘æ—¶å¸¸é‡ã€‚ï¼ˆ`const` å¸¸é‡éšå¼åŒ…å«äº† `final`ã€‚ï¼‰

`final` VS `const`

`final` å˜é‡åœ¨**è¿è¡Œæ—¶**è¢«åˆå§‹åŒ–

`const` å˜é‡åœ¨**ç¼–è¯‘æ—¶**å°±è¢«åˆå§‹åŒ–ä¸”æ˜¯ç¼–è¯‘æ—¶å¸¸é‡



> è™½ç„¶ `final` å¯¹è±¡ä¸èƒ½è¢«ä¿®æ”¹ï¼Œä½†**å®ƒçš„å­—æ®µå¯èƒ½å¯ä»¥è¢«æ›´æ”¹**ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œ`const` å¯¹è±¡åŠå…¶å­—æ®µä¸èƒ½è¢«æ›´æ”¹ï¼šå®ƒä»¬æ˜¯ **ä¸å¯å˜çš„**ã€‚

```dart
  final Map<String, Object> map = {
    "name": 'john',
  };
  // OK
  map['name'] = 'jake';
  
  
  const Map<String, Object> map = {
    "name": 'john',
  };
  // ERROR
  map['name'] = 'jake';
```



# Operator

| cascade | `..`  `?..` |
| ------- | ----------- |

> ä¸¥æ ¼æ¥è¯´ï¼Œçº§è”çš„â€œåŒç‚¹â€è¡¨ç¤ºæ³•ä¸æ˜¯è¿ç®—ç¬¦ã€‚å®ƒåªæ˜¯ Dart è¯­æ³•çš„ä¸€éƒ¨åˆ†ã€‚

cascade æ“ä½œç¬¦ `..` å¯ä»¥ç”¨æ¥å¯¹ä¸€ä¸ªå¯¹è±¡è¿ç»­è°ƒç”¨å¤šä¸ªæ–¹æ³•ï¼Œè€Œä¸éœ€è¦é‡å¤åœ°å¼•ç”¨è¯¥å¯¹è±¡ã€‚cascade æ“ä½œç¬¦ `..` åé¢è·Ÿçš„æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè¯¥è¡¨è¾¾å¼è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œç„¶åå¯¹è¿”å›çš„å¯¹è±¡è¿ç»­è°ƒç”¨å¤šä¸ªæ–¹æ³•ã€‚

```dart
List<int> list = [3, 2, 1];
list..remove(2)..sort();
print(list); // è¾“å‡º [1, 3]


var paint = Paint()
  ..color = Colors.black
  ..strokeCap = StrokeCap.round
  ..strokeWidth = 5.0;
// equivalent to 
var paint = Paint();
paint.color = Colors.black;
paint.strokeCap = StrokeCap.round;
paint.strokeWidth = 5.0;
```

`?..` æ“ä½œç¬¦æ˜¯å¯é€‰ cascade æ“ä½œç¬¦ï¼Œå®ƒä¸ `..` æ“ä½œç¬¦ç±»ä¼¼ï¼Œä½†æ˜¯å½“å·¦ä¾§çš„å¯¹è±¡ä¸º null æ—¶ï¼Œå®ƒä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œè€Œæ˜¯ç›´æ¥è¿”å› nullã€‚

> å¯¹äºé‡‡ç”¨ä¸¤ä¸ªæ“ä½œæ•°çš„è¿ç®—ç¬¦ï¼Œ**æœ€å·¦è¾¹çš„æ“ä½œæ•°å†³å®šä½¿ç”¨å“ªç§æ–¹æ³•**ã€‚
>
> ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨æœ‰ä¸€ä¸ª`Vector`å¯¹è±¡å’Œä¸€ä¸ª`Point`å¯¹è±¡ï¼Œåˆ™`aVector + aPoint`ä½¿ç”¨`Vector`åŠ æ³• ( `+` )ã€‚

```dart
querySelector('#confirm') // Get an object.
  ?..text = 'Confirm' // Use its members.
  ..classes.add('important')
  ..onClick.listen((e) => window.alert('Confirmed!'))
  ..scrollIntoView();

// equivalent to 
var button = querySelector('#confirm');
button?.text = 'Confirm';
button?.classes.add('important');
button?.onClick.listen((e) => window.alert('Confirmed!'));
button?.scrollIntoView();
```



```dart
// åµŒå¥—çº§è”
final addressBook = (AddressBookBuilder()
      ..name = 'jenny'
      ..email = 'jenny@example.com'
      ..phone = (PhoneNumberBuilder()
            ..number = '415-555-0100'
            ..label = 'home')
          .build())
    .build();
```

åœ¨**è¿”å›å®é™…å¯¹è±¡çš„å‡½æ•°ä¸Šæ„å»ºçº§è”æ—¶è¦å°å¿ƒ**ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹ä»£ç ä¼šå¤±è´¥ï¼š

```
var sb = StringBuffer();
sb.write('foo')
  ..write('bar'); // Error: method 'write' isn't defined for 'void'.
```

`sb.write()`è°ƒç”¨è¿”å› voidï¼Œå¹¶ä¸”æ‚¨æ— æ³•åœ¨`void`ä¸Šæ„é€ çº§è”ã€‚





| Operator | Meaning                                                      |
| -------- | ------------------------------------------------------------ |
| `as`     | ç±»å‹è½¬æ¢ï¼ˆä¹Ÿç”¨äºæŒ‡å®š[åº“å‰ç¼€](https://dart.cn/language/libraries#specifying-a-library-prefix): `import xxx as xxx`ï¼‰ |
| `is`     | å¦‚æœå¯¹è±¡å…·æœ‰æŒ‡å®šç±»å‹ï¼Œåˆ™ä¸º True                              |
| `is!`    | (IS NOT) å¦‚æœå¯¹è±¡æ²¡æœ‰æŒ‡å®šçš„ç±»å‹ï¼Œåˆ™ä¸º True                   |

å¦‚æœ`obj`å®ç°äº†`T`æŒ‡å®šçš„æ¥å£ï¼Œåˆ™`obj is T`çš„ç»“æœä¸º trueã€‚ä¾‹å¦‚ï¼Œ `obj is Object?`æ€»æ˜¯æ­£ç¡®çš„ã€‚

å¦‚æœæ‚¨ä¸ç¡®å®šè¯¥å¯¹è±¡çš„ç±»å‹ä¸º`T` ï¼Œè¯·åœ¨ä½¿ç”¨è¯¥å¯¹è±¡ä¹‹å‰ä½¿ç”¨`is T`æ£€æŸ¥ç±»å‹ã€‚

```
if (employee is Person) {
  // Type check
  employee.firstName = 'Bob';
}
```





| `~/` | Divide, returning an integer result (é™¤æ³•ï¼Œè¿”å›æ•´æ•°ç»“æœ) |
| ---- | -------------------------------------------------------- |

```dart
assert(5 ~/ 2 == 2); // Result is an int
```





è¦æµ‹è¯•ä¸¤ä¸ªå¯¹è±¡ x å’Œ y æ˜¯å¦è¡¨ç¤ºåŒä¸€äº‹ç‰©ï¼Œè¯·ä½¿ç”¨`==`è¿ç®—ç¬¦ã€‚(åœ¨æå°‘æ•°æƒ…å†µä¸‹ï¼Œæ‚¨éœ€è¦çŸ¥é“ä¸¤ä¸ªå¯¹è±¡æ˜¯å¦æ˜¯å®Œå…¨ç›¸åŒçš„å¯¹è±¡ï¼Œè¯·ä½¿ç”¨[identical](https://api.dart.cn/stable/dart-core/identical.html)å‡½æ•°ã€‚)

ä»¥ä¸‹æ˜¯`==`è¿ç®—ç¬¦çš„å·¥ä½œåŸç†ï¼š

1. éƒ½ä¸º null è¿”å› trueï¼Œä¸€ä¸ªä¸º nullï¼Œè¿”å› false

2. å°† y ä½œä¸ºå‚æ•° è°ƒç”¨ x çš„ == æ–¹æ³•    ï¼ˆå³ `x.==(y)`)

   ```dart
   class MyClass {
     int value;
   
     MyClass(this.value);
   
     bool operator ==(Object other) {
       print('----- call MyClass == ----- ${other is OtherClass}');
       return other is OtherClass && value == other.value;
     }
   }
   
   class OtherClass {
     int value;
   
     OtherClass(this.value);
   
     bool operator ==(Object other) {
       print('----- call OtherClass == -----');
       return other is MyClass && value == other.value;
     }
   }
   
   void main() {
     MyClass myInstance = MyClass(1);
     OtherClass otherInstance = OtherClass(1);
   
     /**
      * ----- call MyClass == -----
      * true
     **/
     print(myInstance == otherInstance);
   
     /**
      * ----- call MyClass == -----
      * true
     **/
     print(otherInstance == myInstance);
   }
   
   
   ```



ä»…åœ¨åˆ†é…çš„å˜é‡ä¸º null æ—¶è¿›è¡Œåˆ†é…ï¼Œè¯·ä½¿ç”¨`??=`è¿ç®—ç¬¦

```dart
// Assign value to a
a = value;
// Assign value to b if b is null; otherwise, b stays the same
b ??= value;
```







| `>>>` | Unsigned shift right æ— ç¬¦å·å³ç§» |
| ----- | ------------------------------- |

```dart
final value = 0x22;
assert((value >>> 4) == 0x02); // Unsigned shift right
assert((-value >>> 4) > 0); // Unsigned shift right
```

```
æœ‰ç¬¦å·å³ç§»æ“ä½œå‰çš„å€¼ï¼š1111 1111 1111 1111ï¼ˆäºŒè¿›åˆ¶ï¼Œ-1 åè¿›åˆ¶ï¼‰
æœ‰ç¬¦å·å³ç§» 1 ä½åçš„å€¼ï¼š1111 1111 1111 1111ï¼ˆäºŒè¿›åˆ¶ï¼Œ-1 åè¿›åˆ¶ï¼‰
æ— ç¬¦å·å³ç§» 1 ä½åçš„å€¼ï¼š0111 1111 1111 1111ï¼ˆäºŒè¿›åˆ¶ï¼Œ2147483647 åè¿›åˆ¶ï¼‰
```





| spread ([See note](https://dart.cn/language/operators/#spread-operators)) | `...`  `...?` |
| ------------------------------------------------------------ | ------------- |

å¦‚æœæ‰©å±•è¿ç®—ç¬¦å³ä¾§çš„è¡¨è¾¾å¼å¯èƒ½ä¸º nullï¼Œåˆ™å¯ä»¥ä½¿ç”¨æ”¯æŒ null çš„æ‰©å±•è¿ç®—ç¬¦ ( `...?` ) æ¥é¿å…å¼‚å¸¸ï¼š

```
var list2 = [0, ...?list];
assert(list2.length == 1);
```



| `[]`  | Subscript access             | Represents a call to the overridable `[]` operator; example: `fooList[1]` passes the int `1` to `fooList` to access the element at index `1`<br /><br /> |
| ----- | ---------------------------- | ------------------------------------------------------------ |
| `?[]` | Conditional subscript access | ä¸`[]`ç±»ä¼¼ï¼Œä½†æœ€å·¦è¾¹çš„æ“ä½œæ•°å¯ä»¥ä¸º nullï¼›ç¤ºä¾‹ï¼š `fooList?[1]`å°† int `1`ä¼ é€’ç»™`fooList`ä»¥è®¿é—®ç´¢å¼•`1`å¤„çš„å…ƒç´ ï¼Œé™¤é`fooList`ä¸º nullï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹è¡¨è¾¾å¼è®¡ç®—ç»“æœä¸º nullï¼‰ |

> Map åªèƒ½ç”¨ [] è·å–å€¼





# Comments

## Documentation comments

æ–‡æ¡£æ³¨é‡Šæ˜¯ä»¥`///`æˆ–`/**`å¼€å¤´çš„å¤šè¡Œæˆ–å•è¡Œæ³¨é‡Šã€‚åœ¨è¿ç»­è¡Œä¸Šä½¿ç”¨`///`ä¸å¤šè¡Œæ–‡æ¡£æ³¨é‡Šå…·æœ‰ç›¸åŒçš„æ•ˆæœã€‚

```dart
class Food {}

class Activity {}


/// A domesticated South American camelid (Lama glama).
///
/// Andean cultures have used llamas as meat and pack
/// animals since pre-Hispanic times.
///
/// Just like any other animal, llamas need to eat,
/// so don't forget to [feed] them some [Food].
class Llama {
  String? name;

  /// Feeds your llama [food].
  ///
  /// The typical llama eats one bale of hay per week.
  void feed(Food food) {
    // ...
  }

  /// Exercises your llama with an [activity] for
  /// [timeLimit] minutes.
  void exercise(Activity activity, int timeLimit) {
    // ...
  }
}
```

åœ¨ç±»çš„ç”Ÿæˆæ–‡æ¡£ä¸­ï¼Œ `[feed]`æˆä¸º`feed`æ–¹æ³•çš„æ–‡æ¡£é“¾æ¥ï¼Œ `[Food]`æˆä¸º`Food`ç±»çš„æ–‡æ¡£é“¾æ¥ã€‚

è¦è§£æ Dart ä»£ç å¹¶ç”Ÿæˆ HTML æ–‡æ¡£ï¼Œå¯ä»¥ä½¿ç”¨ Dart çš„æ–‡æ¡£ç”Ÿæˆå·¥å…·[`dart doc`](https://dart.cn/tools/dart-doc) ã€‚æœ‰å…³ç”Ÿæˆæ–‡æ¡£çš„ç¤ºä¾‹ï¼Œè¯·å‚é˜…[Dart API æ–‡æ¡£ã€‚](https://api.dart.cn/stable)æœ‰å…³å¦‚ä½•æ„å»ºè¯„è®ºçš„å»ºè®®ï¼Œè¯·å‚é˜…[Effective Dartï¼šæ–‡æ¡£ã€‚](https://dart.cn/effective-dart/documentation)



# Metadata

ä½¿ç”¨å…ƒæ•°æ®æä¾›æœ‰å…³ä»£ç çš„é™„åŠ ä¿¡æ¯ã€‚å…ƒæ•°æ®æ³¨é‡Šä»¥å­—ç¬¦`@`å¼€å¤´ï¼Œåè·Ÿå¯¹ç¼–è¯‘æ—¶å¸¸é‡ï¼ˆä¾‹å¦‚`deprecated` ï¼‰çš„å¼•ç”¨æˆ–å¯¹å¸¸é‡æ„é€ å‡½æ•°çš„è°ƒç”¨ã€‚

> å…ƒæ•°æ®æ³¨é‡Šç”¨äºå‘ä»£ç æä¾›é™„åŠ ä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯åœ¨ç¼–è¯‘æ—¶å¯ä»¥ä½¿ç”¨ï¼Œä½†åœ¨è¿è¡Œæ—¶ä¸ä¼šå½±å“ä»£ç çš„æ‰§è¡Œ

```dart
class Todo {
  final String who;
  final String what;

  const Todo(this.who, this.what);
}

// å¯¹å¸¸é‡æ„é€ å‡½æ•°çš„è°ƒç”¨
@Todo('Dash', 'Implement this function')
void doSomething() {
  print('Do something');
}
```

æ‰€æœ‰ Dart ä»£ç éƒ½å¯ä»¥ä½¿ç”¨å››ä¸ªæ³¨é‡Šï¼š 

- [`@Deprecated`](https://api.dart.cn/stable/dart-core/Deprecated-class.html) éœ€è¦æŒ‡å®šæ¶ˆæ¯ ï¼ˆè§ä¸‹æ–¹ä¾‹å­)
- [`@deprecated`](https://api.dart.cn/stable/dart-core/Deprecated-class.html) ä¸éœ€è¦æŒ‡å®šæ¶ˆæ¯ (è§ä¸‹æ–¹ä¾‹å­)
-  [`@override`](https://api.dart.cn/stable/dart-core/override-constant.html)
- [`@pragma`](https://api.dart.cn/stable/dart-core/pragma-class.html)

```dart
class Television {
  /// Use [turnOn] to turn the power on instead.
  @Deprecated('Use turnOn instead')
  void activate() {
    turnOn();
  }
  
  @deprecated
  void xxx () {}

  /// Turns the TV's power on.
  void turnOn() {...}
  // Â·Â·Â·
}
```





# Libraries & imports

`import`å’Œ`library`æŒ‡ä»¤å¯ä»¥å¸®åŠ©æ‚¨åˆ›å»ºæ¨¡å—åŒ–ä¸”å¯å…±äº«çš„ä»£ç åº“ã€‚åº“ä¸ä»…æä¾› APIï¼Œè€Œä¸”è¿˜æ˜¯ä¸€ä¸ªéšç§å•ä½ï¼š**ä»¥ä¸‹åˆ’çº¿ ( `_` ) å¼€å¤´çš„æ ‡è¯†ç¬¦ä»…åœ¨åº“å†…éƒ¨å¯è§**ã€‚*æ¯ä¸ª Dart æ–‡ä»¶ï¼ˆåŠå…¶éƒ¨åˆ†ï¼‰éƒ½æ˜¯ä¸€ä¸ª[åº“](https://dart.cn/tools/pub/glossary#library)*ï¼Œå³ä½¿å®ƒä¸ä½¿ç”¨[`library`](https://dart.cn/language/libraries/#library-directive)æŒ‡ä»¤ã€‚

åº“å¯ä»¥ä½¿ç”¨[åŒ…(packages)](https://dart.cn/guides/packages)æ¥åˆ†å‘ã€‚

## Using libraries

```dart
import 'dart:html';
```

- å†…ç½®åº“ï¼šç‰¹æ®Šçš„`dart:`scheme
- å…¶å®ƒï¼š
  - æ–‡ä»¶ç³»ç»Ÿè·¯å¾„
  - `package:`scheme ï¼ˆæŒ‡å®šç”±åŒ…ç®¡ç†å™¨ï¼ˆä¾‹å¦‚ pub å·¥å…·ï¼‰æä¾›çš„åº“ï¼‰

## Specifying a library prefix

> æ ‡è¯†ç¬¦å†²çª

```dart
import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as lib2;
// Uses Element from lib1.
Element element1 = Element();

// Uses Element from lib2.
lib2.Element element2 = lib2.Element();
```

## Importing only part of a library 

```dart
// Import only foo.
import 'package:lib1/lib1.dart' show foo;

// Import all names EXCEPT foo.
import 'package:lib2/lib2.dart' hide foo;
```

## Lazily loading a library

æŒ‰éœ€åŠ è½½åº“

`dart`å·¥å…·**ä¸æ”¯æŒé™¤ Web ä¹‹å¤–çš„ç›®æ ‡çš„å»¶è¿ŸåŠ è½½**ã€‚å¦‚æœæ‚¨æ­£åœ¨æ„å»º Flutter åº”ç”¨ç¨‹åºï¼Œè¯·å‚é˜… **Flutter[å»¶è¿Ÿç»„ä»¶](https://docs.flutter.cn/perf/deferred-components)æŒ‡å—** ä¸­çš„å»¶è¿ŸåŠ è½½å®ç°ã€‚

è¦å»¶è¿ŸåŠ è½½åº“ï¼Œè¯·é¦–å…ˆä½¿ç”¨`deferred as`å¯¼å…¥å®ƒã€‚

```dart
import 'package:greetings/hello.dart' deferred as hello;
```

å½“æ‚¨éœ€è¦è¯¥åº“æ—¶ï¼Œè¯·ä½¿ç”¨è¯¥åº“çš„æ ‡è¯†ç¬¦è°ƒç”¨`loadLibrary()` 

```dart
Future<void> greet() async {
  await hello.loadLibrary();
  hello.printGreeting();
}
```

æ‚¨å¯ä»¥åœ¨åº“ä¸Š**å¤šæ¬¡è°ƒç”¨`loadLibrary()`** ï¼Œä¸ä¼šå‡ºç°é—®é¢˜ã€‚**è¯¥åº“ä»…åŠ è½½ä¸€æ¬¡**ã€‚

æ³¨æ„ç‚¹ï¼š

- å»¶è¿Ÿåº“çš„ç±»å‹ä¹Ÿæ˜¯å»¶è¿Ÿå¯¼å…¥ï¼ˆå»ºè®®ä½¿ç”¨å…¬å…±æ–‡ä»¶å¯¼å‡ºä»¥ä¾›ä¸¤è€…ä½¿ç”¨ï¼‰
- Dart éšå¼åœ°å°†`loadLibrary()`æ’å…¥åˆ°æ‚¨ä½¿ç”¨`deferred as namespace`å®šä¹‰çš„å‘½åç©ºé—´ä¸­ã€‚ `loadLibrary()`å‡½æ•°è¿”å›ä¸€ä¸ª[`Future`](https://dart.cn/libraries/dart-async#future) ã€‚

## The `library` directive

è¦æŒ‡å®šåº“çº§[æ–‡æ¡£æ³¨é‡Š](https://dart.cn/effective-dart/documentation#consider-writing-a-library-level-doc-comment)æˆ–[å…ƒæ•°æ®æ³¨é‡Š](https://dart.cn/language/metadata)ï¼Œè¯·å°†å®ƒä»¬é™„åŠ åˆ°æ–‡ä»¶å¼€å¤´çš„`library`å£°æ˜ä¸­ã€‚

```dart
/// A really great test library.
@TestOn('browser')
library;
```



# Built-in types

- [Numbers](https://dart.cn/language/built-in-types/#numbers) (`int`, `double`)
- [Strings](https://dart.cn/language/built-in-types/#strings) (`String`)
- [Booleans](https://dart.cn/language/built-in-types/#booleans) (`bool`)
- [Records](https://dart.cn/language/records) (`(value1, value2)`)
- [Lists](https://dart.cn/language/collections#lists) (`List`, also known as *arrays*)
- [Sets](https://dart.cn/language/collections#sets) (`Set`)
- [Maps](https://dart.cn/language/collections#maps) (`Map`)
- [Runes](https://dart.cn/language/built-in-types/#runes-and-grapheme-clusters) (`Runes`; often replaced by the `characters` API)
- [Symbols](https://dart.cn/language/built-in-types/#symbols) (`Symbol`)
- The value `null` (`Null`)



å…¶ä»–ä¸€äº›ç±»å‹åœ¨ Dart è¯­è¨€ä¸­ä¹Ÿå…·æœ‰ç‰¹æ®Šä½œç”¨ï¼š

- `Object` ï¼šé™¤`Null`ä¹‹å¤–çš„æ‰€æœ‰ Dart ç±»çš„è¶…ç±»ã€‚
- `Enum` ï¼šæ‰€æœ‰æšä¸¾çš„è¶…ç±»ã€‚
- `Iterable` ï¼šç”¨äº[for-in å¾ªç¯](https://dart.cn/libraries/dart-core#iteration)å’ŒåŒæ­¥[ç”Ÿæˆå™¨å‡½æ•°](https://dart.cn/language/functions#generators)ã€‚
- `Never` ï¼šè¡¨ç¤ºè¡¨è¾¾å¼æ°¸è¿œæ— æ³•æˆåŠŸå®Œæˆæ±‚å€¼ã€‚æœ€å¸¸ç”¨äºæ€»æ˜¯æŠ›å‡ºå¼‚å¸¸çš„å‡½æ•°ã€‚
- `dynamic` ï¼šè¡¨ç¤ºæ‚¨è¦ç¦ç”¨é™æ€æ£€æŸ¥ã€‚é€šå¸¸ä½ åº”è¯¥ä½¿ç”¨`Object`è¿˜æ˜¯`Object?`ã€‚
- `void` ï¼šè¡¨ç¤ºä»æœªä½¿ç”¨è¿‡æŸä¸ªå€¼ã€‚é€šå¸¸ç”¨ä½œè¿”å›ç±»å‹ã€‚



`int`: æ•´æ•°å€¼ä¸å¤§äº 64 ä½ï¼Œ[å…·ä½“å–å†³äºå¹³å°](https://dart.cn/guides/language/numbers)

[`double`](https://api.dart.cn/stable/dart-core/double-class.html): 64 ä½ï¼ˆåŒç²¾åº¦ï¼‰æµ®ç‚¹æ•°ï¼Œç”± IEEE 754 æ ‡å‡†æŒ‡å®š

æ‚¨è¿˜å¯ä»¥å°†å˜é‡å£°æ˜ä¸º `num`ã€‚å¦‚æœè¿™æ ·åšï¼Œå˜é‡å¯ä»¥åŒæ—¶å…·æœ‰æ•´æ•°å€¼å’ŒåŒç²¾åº¦å€¼ã€‚

```dart
num x = 1; // x can have both int and double values
x += 2.5;
```

å¿…è¦æ—¶ï¼Œæ•´æ•°å­—é¢é‡ä¼šè‡ªåŠ¨è½¬æ¢ä¸ºåŒç²¾åº¦æ•°ï¼š

```dart
double z = 1; // Equivalent to double z = 1.0.
```

```dart
// String -> int
var one = int.parse('1');
assert(one == 1);

// String -> double
var onePointOne = double.parse('1.1');
assert(onePointOne == 1.1);

// int -> String
String oneAsString = 1.toString();
assert(oneAsString == '1');

// double -> String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == '3.14');
```

## Strings

å¯ä»¥ä½¿ç”¨å•å¼•å·æˆ–åŒå¼•å·æ¥åˆ›å»ºå­—ç¬¦ä¸²

```dart
var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to use the other delimiter.";
```

æ‚¨å¯ä»¥ä½¿ç”¨`${` *`expression`* `}`å°†è¡¨è¾¾å¼çš„å€¼æ”¾å…¥å­—ç¬¦ä¸²ä¸­ã€‚å¦‚æœè¡¨è¾¾å¼æ˜¯æ ‡è¯†ç¬¦ï¼Œåˆ™å¯ä»¥çœç•¥`{}` ã€‚

*ä¸ºäº†è·å–ä¸æŸä¸ªå¯¹è±¡å¯¹åº”çš„å­—ç¬¦ä¸²ï¼ŒDart è°ƒç”¨è¯¥å¯¹è±¡çš„`toString()`æ–¹æ³•*ã€‚

```dart
var s = 'string interpolation';

// ç­‰æ•ˆäº ${s}
assert('Dart has $s'); // Dart has string interpolation
assert('That deserves all caps. '
        '${s.toUpperCase()}' ==
    'That deserves all caps. '
        'STRING INTERPOLATION');
```

æ‚¨å¯ä»¥ä½¿ç”¨ç›¸é‚»çš„å­—ç¬¦ä¸²æ–‡å­—æˆ–`+`è¿ç®—ç¬¦è¿æ¥å­—ç¬¦ä¸²ï¼š

```dart
var s1 = 'a '
    'b'
assert(s1 == 'a b');

var s2 = 'a' + ' ' + 'b';
assert(s2 == 'a b');
```

è¦åˆ›å»ºå¤šè¡Œå­—ç¬¦ä¸²ï¼Œè¯·ä½¿ç”¨å¸¦æœ‰å•å¼•å·æˆ–åŒå¼•å·çš„ä¸‰å¼•å·ï¼š

```dart
var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";
```

You can create a "raw" string by prefixing it with `r`:

```dart
var s = r'In a raw string, not even \n gets special treatment.';
```

## Boolean

Dart çš„ç±»å‹å®‰å…¨æ„å‘³ç€æ‚¨ä¸èƒ½ä½¿ç”¨`if ( *nonbooleanValue* )`æˆ–`assert ( *nonbooleanValue* )`ç­‰ä»£ç ã€‚ç›¸åï¼Œæ˜¾å¼æ£€æŸ¥å€¼ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```dart
// Check for an empty string.
var fullName = '';
assert(fullName.isEmpty);

// Check for zero.
var hitPoints = 0;
assert(hitPoints == 0);

// ... 
```

## Runes and grapheme clusters (ç¬¦æ–‡å’Œå­—ç´ ç°‡)

åœ¨ Dart ä¸­ï¼Œ[ç¬¦æ–‡](https://api.dart.cn/stable/dart-core/Runes-class.html)å…¬å¼€å­—ç¬¦ä¸²çš„ Unicode ä»£ç ç‚¹ã€‚æ‚¨å¯ä»¥ä½¿ç”¨[å­—ç¬¦åŒ…](https://pub-web.flutter-io.cn/packages/characters)æ¥æŸ¥çœ‹æˆ–æ“ä½œç”¨æˆ·æ„ŸçŸ¥çš„å­—ç¬¦ï¼Œä¹Ÿç§°ä¸º[Unicodeï¼ˆæ‰©å±•ï¼‰å­—ç´ ç°‡ã€‚](https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)

å¦‚æœéœ€è¦è¯»å–æˆ–å†™å…¥å•ä¸ª Unicode å­—ç¬¦ï¼Œè¯·ä½¿ç”¨å­—ç¬¦åŒ…åœ¨ String ä¸Šå®šä¹‰çš„`characters` getterã€‚è¿”å›çš„[`Characters`](https://pub-web.flutter-io.cn/documentation/characters/latest/characters/Characters-class.html)å¯¹è±¡æ˜¯ä½œä¸ºå­—ç´ ç°‡åºåˆ—çš„å­—ç¬¦ä¸²ã€‚ä»¥ä¸‹æ˜¯ä½¿ç”¨å­—ç¬¦ API çš„ç¤ºä¾‹ï¼š

```dart
import 'package:characters/characters.dart';

void main() {
  var hi = 'Hi ğŸ‡©ğŸ‡°';
  print(hi);
  print('The end of the string: ${hi.substring(hi.length - 1)}');
  print('The last character: ${hi.characters.last}');
}
```

## Symbols

è¦è·å–æ ‡è¯†ç¬¦çš„ç¬¦å·ï¼Œè¯·ä½¿ç”¨ç¬¦å·æ–‡å­—ï¼Œå³`#`åè·Ÿæ ‡è¯†ç¬¦ï¼š

```dart
#radix
#bar
```

Symbols literals æ˜¯ç¼–è¯‘æ—¶å¸¸é‡ã€‚



# Records

åŒ¿åçš„ã€ä¸å¯å˜çš„èšåˆç±»å‹

- å›ºå®šå¤§å°çš„
- å¼‚æ„
- ç±»å‹åŒ–

## Record syntax

comma-delimited lists of named or positional fields

ä»¥**é€—å·åˆ†éš”**çš„  å‘½åæˆ–ä½ç½®å­—æ®µ åˆ—è¡¨

```dart
var record = ('first', a: 2, b: true, 'last');
```

```dart
(int, int) swap((int, int) record) {
  var (a, b) = record;
  return (b, a);
}
```

å‘½åå­—æ®µåœ¨å¤§æ‹¬å·å†…ï¼Œ**ä½äºæ‰€æœ‰ä½ç½®å­—æ®µä¹‹å**

```dart
// Record type annotation in a variable declaration:
({int a, bool b}) record;

// Initialize it with a record expression:
record = (a: 123, b: true);
```



The names of named fields in a record type are part of the [record's type definition](https://dart.cn/language/records/#record-types), or its *shape*. Two records with named fields with different names have different types:
è®°å½•ç±»å‹ä¸­å‘½åå­—æ®µçš„åç§°æ˜¯[è®°å½•ç±»å‹å®šä¹‰](https://dart.cn/language/records/#record-types)æˆ–å…¶*å½¢çŠ¶*çš„ä¸€éƒ¨åˆ†ã€‚å…·æœ‰ä¸åŒåç§°çš„å‘½åå­—æ®µçš„ä¸¤æ¡è®°å½•å…·æœ‰ä¸åŒçš„ç±»å‹ï¼š

```dart
({int a, int b}) recordAB = (a: 1, b: 2);
({int x, int y}) recordXY = (x: 3, y: 4);

// Compile error! These records don't have the same type.
// recordAB = recordXY;

(int x, int y, int z) point = (1, 2, 3);
(int r, int g, int b) color = (1, 2, 3);
print(point == color); // Prints 'true'.
point = color // OK

({int x, int y, int z}) point = (x: 1, y: 2, z: 3);
({int r, int g, int b}) color = (r: 1, g: 2, b: 3);
print(point == color); // Prints 'false'. Lint: Equals on unrelated types.
point = color // OK

```

åœ¨è®°å½•ç±»å‹æ³¨é‡Šä¸­ï¼Œæ‚¨è¿˜å¯ä»¥å‘½å*ä½ç½®*å­—æ®µï¼Œä½†è¿™äº›åç§°çº¯ç²¹ç”¨äºæ–‡æ¡£ï¼Œä¸ä¼šå½±å“è®°å½•çš„ç±»å‹ï¼š

```dart
// a båªæ˜¯ç”¨äºæ³¨é‡Šï¼Œå¯ä»¥çœç•¥
(int a, int b) recordAB = (1, 2);
(int x, int y) recordXY = (3, 4);

recordAB = recordXY; // OK.
```

è¿™ç±»ä¼¼äºå‡½æ•°å£°æ˜æˆ–å‡½æ•° typedef ä¸­çš„ä½ç½®å‚æ•°å¯ä»¥å…·æœ‰åç§°ï¼Œä½†è¿™äº›åç§°ä¸ä¼šå½±å“å‡½æ•°çš„ç­¾åã€‚



æ‚¨è¿˜å¯ä»¥ä½¿ç”¨å…¶[å‘½å fields](https://dart.cn/language/records/#record-fields)å’Œå†’å·`:`è¯­æ³•æ¥è§£æ„è®°å½•

```dart
({String name, int age}) userInfo(Map<String, dynamic> json)
// Â·Â·Â·
// Destructures using a record pattern with named fields:
final (:name, :age) = userInfo(json);
```





# Collections

## Lists

## Sets

è¦åˆ›å»ºç©ºé›†ï¼Œè¯·ä½¿ç”¨å‰é¢å¸¦æœ‰ç±»å‹å‚æ•°çš„`{}` ï¼Œæˆ–å°†`{}`åˆ†é…ç»™`Set`ç±»å‹çš„å˜é‡ï¼š

```dart
var names = <String>{};
// Set<String> names = {}; // This works, too.
// var names = {}; // Creates a map, not a set.
```

æ–¹æ³•

- `add`
- `addAll()`

```dart
var strings = ['1', '2'];
var elements = <String>{};
elements.add('fluorine');
elements.addAll(strings);

// ä½¿ç”¨.lengthè·å–é›†åˆä¸­çš„é¡¹ç›®æ•°
assert(elements.length == 3);
```

## Maps 

```dart
var gifts = {'first': 'partridge'};

// ä½¿ç”¨ä¸‹æ ‡èµ‹å€¼è¿ç®—ç¬¦ ( `[]=` ) å°†æ–°çš„é”®å€¼å¯¹æ·»åŠ åˆ°ç°æœ‰æ˜ å°„ï¼š
gifts['fourth'] = 'calling birds'; // Add a key-value pair

// ä½¿ç”¨ä¸‹æ ‡è¿ç®—ç¬¦ ( `[]` ) ä»æ˜ å°„ä¸­æ£€ç´¢å€¼ï¼š
assert(gifts['first'] == 'partridge');

// å¦‚æœæ‚¨æŸ¥æ‰¾åœ°å›¾ä¸­ä¸å­˜åœ¨çš„é”®ï¼Œåˆ™ä¼šå¾—åˆ°`null`ä½œä¸ºè¿”å›ï¼š
assert(gifts['fifth'] == null);

// ä½¿ç”¨`.length`è·å–æ˜ å°„ä¸­é”®å€¼å¯¹çš„æ•°é‡ï¼š
gifts['fourth'] = 'calling birds';
assert(gifts.length == 2);
```



## Operators

### Spread operators

```dart
var list = [1, 2, 3];
var list2 = [0, ...list];
assert(list2.length == 4);

// å¦‚æœæ‰©å±•è¿ç®—ç¬¦å³ä¾§çš„è¡¨è¾¾å¼å¯èƒ½ä¸º nullï¼Œåˆ™å¯ä»¥ä½¿ç”¨æ”¯æŒ null çš„æ‰©å±•è¿ç®—ç¬¦ ( ...? ) æ¥é¿å…å¼‚å¸¸ï¼š
var list2 = [0, ...?list];
assert(list2.length == 1);


```

### Control-flow operators

```dart
var nav = ['Home', 'Furniture', 'Plants', if (promoActive) 'Outlet'];

// if-case
// Dart ifè¯­å¥æ”¯æŒcaseå­å¥åè·Ÿæ¨¡å¼
var nav = ['Home', 'Furniture', 'Plants', if (login case 'Manager') 'Inventory'];

// ä»¥ä¸‹æ˜¯åœ¨å°†åˆ—è¡¨é¡¹æ·»åŠ åˆ°å¦ä¸€ä¸ªåˆ—è¡¨ä¹‹å‰ä½¿ç”¨é›†åˆæ¥æ“ä½œåˆ—è¡¨é¡¹çš„ç¤ºä¾‹ï¼š
var listOfInts = [1, 2, 3];
var listOfStrings = ['#0', for (var i in listOfInts) '#$i'];
assert(listOfStrings[1] == '#1');
```



# [æ³›å‹ (Generics) ](https://dart.cn/language/generics)

## Restricting the parameterized type

ä¸€ä¸ªå¸¸è§çš„ç”¨ä¾‹æ˜¯é€šè¿‡ä½¿å…¶æˆä¸º`Object`çš„å­ç±»å‹ï¼ˆè€Œä¸æ˜¯é»˜è®¤çš„[`Object?`](https://dart.cn/null-safety/understanding-null-safety#top-and-bottom) ï¼‰æ¥ç¡®ä¿ç±»å‹ä¸å¯ä¸º nullã€‚

```dart
class Foo<T extends Object> {
  // Any type provided to Foo for T must be non-nullable.
}
```







# Typedefs

ç±»å‹åˆ«åï¼ˆtype aliasï¼‰ç±»ä¼¼ TS ä¸­çš„ `type`

```dart
typedef IntList = List<int>;
IntList il = [1, 2, 3];
```

**å¯ä»¥æœ‰ç±»å‹å‚æ•°**ï¼š

```dart
typedef ListMapper<X> = Map<X, List<X>>;
Map<String, List<String>> m1 = {}; // Verbose.
ListMapper<String> m2 = {}; // Same thing but shorter and clearer.
```

åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å»ºè®®ä½¿ç”¨[å†…è”å‡½æ•°ç±»å‹](https://dart.cn/effective-dart/design#prefer-inline-function-types-over-typedefs)è€Œä¸æ˜¯å‡½æ•°çš„ typedefã€‚ç„¶è€Œï¼Œå‡½æ•° typedef ä»ç„¶æœ‰ç”¨ï¼š

```dart
typedef Compare<T> = int Function(T a, T b);

int sort(int a, int b) => a - b;

void main() {
  assert(sort is Compare<int>); // True!
}
```







# Patterns

ä¸€èˆ¬æ¥è¯´ï¼Œæ¨¡å¼å¯ä»¥**åŒ¹é…**å€¼ã€**è§£æ„**å€¼æˆ–ä¸¤è€…å…¼è€Œæœ‰ä¹‹ï¼Œå…·ä½“å–å†³äºæ¨¡å¼çš„ä¸Šä¸‹æ–‡å’Œå½¢çŠ¶

é¦–å…ˆï¼Œ*æ¨¡å¼åŒ¹é…*å…è®¸æ‚¨æ£€æŸ¥ç»™å®šå€¼æ˜¯å¦ï¼š

- Has a certain shape. å…·æœ‰ä¸€å®šçš„å½¢çŠ¶
  - è¿™é€šå¸¸æ¶‰åŠåˆ°å¯¹æ•°æ®ç»“æ„çš„å†…éƒ¨ç»„æˆè¿›è¡Œæ£€æŸ¥ï¼‰
- Is a certain constant. æ˜¯ä¸€å®šçš„å¸¸æ•°
- Is equal to something else. ç­‰äºå…¶ä»–ä¸œè¥¿
- Has a certain type. æœ‰ä¸€å®šçš„ç±»å‹ 
  - æ˜¯å¦å±äºç‰¹å®šçš„ç±»å‹ï¼Œè¿™ä¸æ£€æŸ¥å½¢çŠ¶ä¸åŒï¼Œå› ä¸ºå®ƒå…³æ³¨çš„æ˜¯å€¼çš„ç±»å‹ï¼Œè€Œä¸æ˜¯å€¼çš„å†…éƒ¨ç»“æ„ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥æ£€æŸ¥ä¸€ä¸ªå€¼æ˜¯å¦æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²æˆ–ä¸€ä¸ªæ•´æ•°ï¼Œè€Œä¸å…³å¿ƒå®ƒçš„å…·ä½“å†…å®¹æˆ–ç»“æ„ã€‚

### 

æ‚¨å¯ä»¥åœ¨è§£æ„æ¨¡å¼ä¸­åµŒå¥—[ä»»ä½•ç±»å‹çš„æ¨¡å¼](https://dart.cn/language/pattern-types)ã€‚ä¾‹å¦‚ï¼Œæ­¤ case æ¨¡å¼åŒ¹é…å¹¶è§£æ„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸º`'a'`æˆ–`'b'`çš„äºŒå…ƒç´ åˆ—è¡¨ï¼š

```dart
switch (list) {
  case ['a' || 'b', var c]:
    print(c);
}
```



## Places patterns can appear 

- Local variable [declarations](https://dart.cn/language/patterns/#variable-declaration) and [assignments](https://dart.cn/language/patterns/#variable-assignment)
- [for and for-in loops](https://dart.cn/language/loops#for-loops)
- [if-case](https://dart.cn/language/branches#if-case) and [switch-case](https://dart.cn/language/branches#switch-statements)
- Control flow in [collection literals](https://dart.cn/language/collections#control-flow-operators)



### Variable declaration

```dart
// Declares new variables a, b, and c.
var (a, [b, c]) = ('str', [1, 2]);
```

### Variable assignment

```dart
var (a, b) = ('left', 'right');
(b, a) = (a, b); // Swap.
print('$a $b'); // Prints "right left".
```

### Switch è¯­å¥å’Œè¡¨è¾¾å¼

æ¯ä¸ª case å­å¥éƒ½åŒ…å«ä¸€ä¸ªæ¨¡å¼ã€‚è¿™é€‚ç”¨äº[switch è¯­å¥](https://dart.cn/language/branches#switch-statements)å’Œ[è¡¨è¾¾å¼](https://dart.cn/language/branches#switch-expressions)ï¼Œä»¥åŠ[if-case è¯­å¥](https://dart.cn/language/branches#if-case)ã€‚æ‚¨å¯ä»¥åœ¨æ¡ˆä¾‹ä¸­ä½¿ç”¨[ä»»ä½•ç±»å‹çš„å›¾æ¡ˆ](https://dart.cn/language/pattern-types)ã€‚

```dart
switch (obj) {
  // Matches if 1 == obj.
  case 1:
    print('one');

  // Matches if the value of obj is between the
  // constant values of 'first' and 'last'.
  case >= first && <= last:
    print('in range');

  // Matches if obj is a record with two fields,
  // then assigns the fields to 'a' and 'b'.
  case (var a, var b):
    print('a = $a, b = $b');

  default:
}
```

[é€»è¾‘æˆ–æ¨¡å¼](https://dart.cn/language/pattern-types#logical-or)å¯¹äºè®©å¤šä¸ª case åœ¨ switch è¡¨è¾¾å¼æˆ–è¯­å¥ä¸­å…±äº«ä¸€ä¸ªä¸»ä½“éå¸¸æœ‰ç”¨ï¼š

```dart
var isPrimary = switch (color) {
  Color.red || Color.yellow || Color.blue => true,
  _ => false
};



sealed class Shape {}

class Square implements Shape {
  final double length;
  Square(this.length);
}

class Circle implements Shape {
  final double radius;
  Circle(this.radius);
}

double calculateArea(Shape shape) => switch (shape) {
    Square(length: var l) => l * l,
    Circle(radius: var r) => math.pi * r * r
};

```

[Guard clauses](https://dart.cn/language/branches#guard-clause) evaluate an arbitrary condition as part of a case, **without exiting the switch if the condition is false** (like using an `if` statement in the case body would cause).

>  æ³¨ï¼šå½“ when ä¸æ»¡è¶³æ—¶ï¼Œè·³è¿‡å½“å‰ case ä¸”ä¸é€€å‡º switch

```dart
// Switch statement:
switch (something) {
  case somePattern when some || boolean || expression:
    //             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Guard clause.
    body;
}

// Switch expression:
var value = switch (something) {
  somePattern when some || boolean || expression => body,
  //               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Guard clause.
}

// If-case statement:
if (something case somePattern when some || boolean || expression) {
  //                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Guard clause.
  body;
}
```

### For and for-in loops for 

```dart
Map<String, int> hist = {
  'a': 23,
  'b': 100,
};

for (var MapEntry(key: key, value: count) in hist.entries) {
  print('$key occurred $count times');
}

// ç®€åŒ–
for (var MapEntry(:key, value: count) in hist.entries) {
  print('$key occurred $count times');
}
```

## Use cases for patterns

- *When and why* you might want to use patterns.
  æ‚¨*ä½•æ—¶ä»¥åŠä¸ºä½•*éœ€è¦ä½¿ç”¨æ¨¡å¼ã€‚
- What kinds of problems they solve.
  ä»–ä»¬è§£å†³ä»€ä¹ˆæ ·çš„é—®é¢˜ã€‚
- Which idioms they best suit.
  å®ƒä»¬æœ€é€‚åˆå“ªäº›æˆè¯­ã€‚

### Destructuring multiple returns

```dart
(String name, int age) userInfo(Map<String, dynamic> json) {
  return (json['name'] as String, json['age'] as int);
}

final json = <String, dynamic>{
  'name': 'Dash',
  'age': 10,
  'color': 'blue',
};

// Destructures using a record pattern with positional fields:
var (name, age) = userInfo(json);

/* Equivalent to:
  var info = userInfo(json);
  var name = info.$1;
  var age  = info.$2;
*/



// To destructure a record with named fields using a pattern:
final (:name, :age) =
    getData(); // For example, return (name: 'doug', age: 25);
    
    
```

### Destructuring class instances

[Object patterns](https://dart.cn/language/pattern-types#object) match against named object types, allowing you to destructure their data using **the getters the object's class already exposes**.
[å¯¹è±¡æ¨¡å¼](https://dart.cn/language/pattern-types#object)ä¸å‘½åå¯¹è±¡ç±»å‹ç›¸åŒ¹é…ï¼Œå…è®¸æ‚¨ä½¿ç”¨å¯¹è±¡**ç±»å·²ç»å…¬å¼€çš„ getter** æ¥è§£æ„å…¶æ•°æ®ã€‚

```dart
final Foo myFoo = Foo(one: 'one', two: 2);
var Foo(:one, :two) = myFoo;
print('one $one, two $two');
```

### Validating incoming JSON

```dart
// ä½†æ•°æ®é€šå¸¸æ¥è‡ªå¤–éƒ¨æ¥æºï¼Œä¾‹å¦‚é€šè¿‡ç½‘ç»œã€‚æ‚¨éœ€è¦å…ˆå¯¹å…¶è¿›è¡ŒéªŒè¯ä»¥ç¡®è®¤å…¶ç»“æ„ã€‚
// å¦‚æœæ²¡æœ‰æ¨¡å¼ï¼ŒéªŒè¯å°±ä¼šå¾ˆå†—é•¿ï¼š
if (json is Map<String, Object?> &&
    json.length == 1 &&
    json.containsKey('user')) {
  var user = json['user'];
  if (user is List<Object> &&
      user.length == 2 &&
      user[0] is String &&
      user[1] is int) {
    var name = user[0] as String;
    var age = user[1] as int;
    print('User $name is $age years old.');
  }
}

// equivalent to
if (json case {'user': [String name, int age]}) {
  print('User $name is $age years old.');
}
```

# Pattern types

## Logical-or

`subpattern1 || subpattern2`

```dart
var isPrimary = switch (color) {
  Color.red || Color.yellow || Color.blue => true,
  _ => false
};
```

## Logical-and

`subpattern1 && subpattern2`

```dart
switch ((1, 2)) {
  // Error, both subpatterns attempt to bind 'b'.
  case (var a, var b) && (var b, var c): // ...
}
```

## Relational

```
== expression
< expression
```

```dart
String asciiCharType(int char) {
  const space = 32;
  const zero = 48;
  const nine = 57;

  return switch (char) {
    < space => 'control',
    == space => 'space',
    > space && < zero => 'punctuation',
    >= zero && <= nine => 'digit',
    // deafult 
    _ => ''
  };
}
```

## Cast 

`foo as String`

A cast pattern lets you **insert a [type cast](https://dart.cn/language/operators#type-test-operators) in the middle of destructuring**, before passing the value to another subpattern:

```dart
(num, Object) record = (1, 's');
var (i as int, s as String) = record;
```

## Null-check

`subpattern?`

To **treat `null` values as match failures without throwing**, use the null-check pattern.

```dart
String? maybeString = 'nullable with base type String';
switch (maybeString) {
  case var s?:
  // 's' has type non-nullable String here.
}
```

To match when the value *is* null, use the [constant pattern](https://dart.cn/language/pattern-types/#constant) `null`

## Null-assert

`subpattern!`

Null-assert patterns match first if the object is not null, then on the value. They **permit non-null values to flow through, but [throw](https://dart.cn/language/error-handling#throw) if the matched value is null**.

```dart
List<String?> row = ['user', null];
switch (row) {
  // this will THROW ERROR
  case ['user', var name!]: // ...
  // 'name' is a non-nullable string here.
}
```

è¦ä»å˜é‡å£°æ˜æ¨¡å¼ä¸­æ¶ˆé™¤`null`å€¼ï¼Œè¯·ä½¿ç”¨ç©ºæ–­è¨€æ¨¡å¼ï¼š

```dart
(int?, int?) position = (2, 3);

var (x!, y!) = position;
```

## Constant

`123`, `null`, `'string'`, `math.pi`, `SomeClass.constant`, `const Thing(1, 2)`,` const (1 + 2)`

```dart
switch (number) {
  // Matches if 1 == number.
  case 1: // ...
}
```

- Number literals (`123`, `45.56`)
  æ•°å­—æ–‡å­— ( `123` , `45.56` )
- Boolean literals (`true`)
  å¸ƒå°”æ–‡å­— ( `true` )
- String literals (`'string'`)
  å­—ç¬¦ä¸²æ–‡å­— ( `'string'` )
- Named constants (`someConstant`, `math.pi`, `double.infinity`)
  å‘½åå¸¸é‡ï¼ˆ `someConstant` ã€ `math.pi` ã€ `double.infinity` ï¼‰
- Constant constructors (`const Point(0, 0)`)
  å¸¸é‡æ„é€ å‡½æ•° ( `const Point(0, 0)` )
- Constant collection literals (`const []`, `const {1, 2}`)
  å¸¸é‡é›†åˆæ–‡å­— ( `const []` , `const {1, 2}` )

æ›´å¤æ‚çš„å¸¸é‡è¡¨è¾¾å¼å¿…é¡»åŠ æ‹¬å·å¹¶ä»¥`const` ä¸ºå‰ç¼€: ( `const (1 + 2)` )

```dart
// List or map pattern:
case [a, b]: // ...

// List or map literal:
case const [a, b]: // ...
```

## Parenthesized (å¸¦æ‹¬å·çš„)

- control [pattern precedence](https://dart.cn/language/pattern-types/#pattern-precedence) 

- insert a lower-precedence pattern where a higher precedence one is expected

```dart
var x = true;
var y = true;
var z = false;

// ...
x || y => 'matches true',

// `x || y && z` is the same thing as `x || (y && z)`.
x || y && z => 'matches true',
x || (y && z) => 'matches true',

(x || y) && z => 'matches nothing',
// ...
```

## List 

`[subpattern1, subpattern2]`

### Rest element

```dart
var [a, b, ..., c, d] = [1, 2, 3, 4, 5, 6, 7];
// Prints "1 2 6 7".
print('$a $b $c $d');

var [a, b, ...rest, c, d] = [1, 2, 3, 4, 5, 6, 7];
// Prints "1 2 [3, 4, 5] 6 7".
print('$a $b $rest $c $d');
```

## Map 

`{"key": subpattern1, someConst: subpattern2}`

Map patterns **don't require the pattern to match the entire map**. A map pattern ignores any keys that the map contains that aren't matched by the pattern.

```dart
Map<String, dynamic> map = {
  'name': 'jack',
  'age': 25,
};

switch (map) {
  // FAIL
  case {
    'name': String,
    'age': num,
  }:
    print('name is a string');  
    // OK
  case {
    'name': String _,
    'age': num _,
  }:
    print('name is a string');
    // OK
  case {
    'name': String _,
  }:
    print('name is a string');

}

// OK
if (map
    case {
      'name': String _,
      'age': num _,
    }) {
  print('The name is a string');
}

```

æ³¨æ„ï¼šæ­¤å¤„ä¸èƒ½ç”¨

```dart
case {
    'name': String,
    'age': num,
  }:
```

åŒ¹é…ï¼Œå› æ­¤è¿™é‡Œçš„ `String` å’Œ `num`ï¼Œ è¡¨ç¤ºè¯¥å±æ€§çš„å€¼ä¸º `String` å’Œ `num` ç±»æœ¬èº«ï¼Œæµ‹è¯•å¦‚ä¸‹ï¼š

```dart
void main() {
  Map<String, Object> map = {
    'name': String,
    'age': num,
  };

  // OK
  if (map case {'name': String, 'age': num}) {
    print('Name: $map["name"]');
    print('Age: $map["age"]');
  }
}


```





## Record 

`(subpattern1, subpattern2)`

Record patterns require that the pattern **match the entire record**. To destructure a record with *named* fields using a pattern, include the field names in the pattern

```dart
var (myString: foo, myNumber: bar) = (myString: 'string', myNumber: 1);
```

å¯ä»¥çœç•¥ getter åç§°ï¼Œå¹¶ä»å­—æ®µå­æ¨¡å¼ä¸­çš„å˜é‡æ¨¡å¼æˆ–æ ‡è¯†ç¬¦æ¨¡å¼æ¨æ–­å‡ºæ¥ã€‚è¿™äº›æ¨¡å¼å¯¹éƒ½æ˜¯ç­‰æ•ˆçš„

```dart
// Record pattern with variable subpatterns:
var (untyped: untyped, typed: int typed) = record;
var (:untyped, :int typed) = record;

switch (record) {
  case (untyped: var untyped, typed: int typed): // ...
  case (:var untyped, :int typed): // ...
}

// Record pattern with null-check and null-assert subpatterns:
switch (record) {
  case (checked: var checked?, asserted: var asserted!): // ...
  case (:var checked?, :var asserted!): // ...
}

// Record pattern with cast subpattern:
var (untyped: untyped as int, typed: typed as String) = record;
var (:untyped as int, :typed as String) = record;
```

## Object 

`SomeClass(x: subpattern1, y: subpattern2)`

Object patterns **don't require the pattern to match the entire object**. If an object has extra fields that the pattern doesn't destructure, it can still match.

```dart
switch (shape) {
  // Matches if shape is of type Rect, and then against the properties of Rect.
  case Rect(width: var w, height: var h): // ...
}


// Binds new variables x and y to the values of Point's x and y properties.
var Point(:x, :y) = Point(1, 2);


class Axis {
  int x;
  int y;
  int z;
  Axis(this.x, this.y, this.z);
}

void main() {
  var Point(:x, :y) = Axis(1, 2, 3);
  print('${x} ${y}'); // 1 2
}

```

## Wildcard

åœ¨éœ€è¦å­æ¨¡å¼çš„åœ°æ–¹ï¼Œå®ƒä½œä¸ºå ä½ç¬¦å¾ˆæœ‰ç”¨ï¼Œä»¥ä¾¿è§£æ„ä»¥åçš„ä½ç½®å€¼

```dart
var list = [1, 2, 3];
var [_, two, _] = list;
```

å½“æ‚¨æƒ³**è¦æµ‹è¯•å€¼çš„ç±»å‹ä½†ä¸å°†è¯¥å€¼ç»‘å®šåˆ°åç§°æ—¶**ï¼Œå¸¦æœ‰ç±»å‹æ³¨é‡Šçš„é€šé…ç¬¦åç§°éå¸¸æœ‰ç”¨

```dart
switch (record) {
  case (int _, String _):
    print('First field is int and second is String.');
}
```

# Functions

Dart is a true object-oriented language, so **even functions are objects and have a type, [Function.](https://api.dart.cn/stable/dart-core/Function-class.html) **

### Named parameters

`{param1, param2, â€¦}`

å‘½åå‚æ•°æ˜¯å¯é€‰çš„ï¼Œé™¤éå®ƒä»¬è¢«æ˜ç¡®æ ‡è®°ä¸º `required` 

```dart
// address ç±»å‹ä¸º String? å› ä¸ºå®ƒå¯ä»¥ä¸º null
void foo({ required num age, String? address }) {}

foo(age: 30);
foo(age: 30, address: 'shanghai');
```



```dart
// default value
void enableFlags({bool bold = false, bool hidden = false}) {...}
// bold will be true; hidden will be false.
enableFlags(bold: true);

// æ ‡è®°ä¸º required çš„å‚æ•°ä»ç„¶å¯ä»¥ä¸ºç©ºï¼š
const Scrollbar({super.key, required Widget? child});

```

You *might want to place positional arguments first*, but Dart doesn't require it. Dart **allows named arguments to be placed anywhere** in the argument list *when it suits your API*

```dart
void foo(String name, {required num age}) {}

// both OK
foo('jack', age: 25);
foo(age: 25, 'jack');
```

### Positiontal Parameters



### Optional positional parameters

å°†ä¸€ç»„å‡½æ•°å‚æ•°åŒ…è£…åœ¨ `[]` ä¸­å°†å®ƒä»¬æ ‡è®°ä¸ºå¯é€‰ä½ç½®å‚æ•°ã€‚å¦‚æœæ‚¨ä¸æä¾›é»˜è®¤å€¼ï¼Œåˆ™å®ƒä»¬çš„ç±»å‹å¿…é¡»å¯ä¸ºç©ºï¼Œå› ä¸ºå®ƒä»¬çš„é»˜è®¤å€¼å°†ä¸º `null` 

```dart
String say(String from, String msg, [String? device]) {
  var result = '$from says $msg';
  if (device != null) {
    result = '$result with a $device';
  }
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy');

assert(say('Bob', 'Howdy', 'smoke signal') ==
    'Bob says Howdy with a smoke signal');


// With default value
String say(String from, String msg, [String device = 'carrier pigeon']) {
  var result = '$from says $msg with a $device';
  return result;
}

assert(say('Bob', 'Howdy') == 'Bob says Howdy with a carrier pigeon');
```





Dart è¯­æ³•è¦æ±‚**ä½ç½®å‚æ•°å¿…é¡»åœ¨å‘½åå‚æ•°ä¹‹å‰**ã€‚è¿™æ˜¯å› ä¸ºä½ç½®å‚æ•°çš„è°ƒç”¨æ˜¯åŸºäºå‚æ•°çš„ä½ç½®çš„ï¼Œå¦‚æœå…è®¸åœ¨å‘½åå‚æ•°ä¹‹åå‡ºç°ä½ç½®å‚æ•°ï¼Œç¼–è¯‘å™¨å°†éš¾ä»¥æ­£ç¡®è§£æå’ŒåŒ¹é…å‚æ•°

```dart
// é”™è¯¯çš„æ ·ä¾‹
void foo({required num age}, String name) {}
// è°ƒç”¨æ—¶ ç¼–è¯‘å™¨å¯èƒ½ä¼šæ··æ·†ï¼Œå› ä¸ºå®ƒæ— æ³•è½»æ˜“åŒºåˆ†å“ªä¸ªå€¼å¯¹åº”å“ªä¸ªå‚æ•°ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½ç½®å‚æ•°å¿…é¡»å…ˆäºå‘½åå‚æ•°
foo(age: 30, "John");
```

A function can have any number of *required positional* parameters. These can be followed either by *named* parameters or by *optional positional* parameters (but not both).

å‡½æ•°å¯ä»¥å…·æœ‰ä»»æ„æ•°é‡çš„å¿…é€‰ä½ç½®å‚æ•°ã€‚è¿™äº›å‚æ•°åé¢å¯ä»¥è·Ÿæœ‰å‘½åå‚æ•°æˆ–å¯é€‰çš„ä½ç½®å‚æ•°ï¼ˆä½†ä¸èƒ½åŒæ—¶è·Ÿæœ‰ä¸¤è€…ï¼‰ã€‚

å³ï¼š**å¯é€‰ä½ç½®å‚æ•°**ï¼ˆoptional positional parametersï¼‰å’Œ **å‘½åå‚æ•°**ï¼ˆnamed parametersï¼‰ä¸èƒ½åŒæ—¶å‡ºç°åœ¨åŒä¸€ä¸ªå‡½æ•°çš„å‚æ•°åˆ—è¡¨ä¸­

```dart
// ERROR
void foo(String name, [String? company = 'hh'], { required num age, String? address }) {}

// OK
void foo(String name, [String? company = 'hh']) {}
void foo(String name, { required num age }) {}
```







## The main() function

æ¯ä¸ªåº”ç”¨ç¨‹åºéƒ½å¿…é¡»æœ‰ä¸€ä¸ªé¡¶çº§ `main()` å‡½æ•°ï¼Œä½œä¸ºåº”ç”¨ç¨‹åºçš„å…¥å£ç‚¹ã€‚ `main()` å‡½æ•°è¿”å› `void` å¹¶**å…·æœ‰å¯é€‰çš„ `List<String>` å‚æ•°ä½œä¸ºå‚æ•°ã€‚**

```dart
// Run the app like this: dart run args.dart 1 test
void main(List<String> arguments) {
  print(arguments);

  assert(arguments.length == 2);
  assert(int.parse(arguments[0]) == 1);
  assert(arguments[1] == 'test');
}
```



## Functions as first-class objects

> â€œä¸€ç­‰å…¬æ°‘â€ (First-Class Citizens) æ˜¯ç¼–ç¨‹è¯­è¨€ç†è®ºä¸­çš„ä¸€ä¸ªæœ¯è¯­ï¼Œæœ€æ—©å¯ä»¥è¿½æº¯åˆ°è®¡ç®—æœºç§‘å­¦å®¶ Christopher Strachey åœ¨ 1960 å¹´ä»£çš„ç ”ç©¶å·¥ä½œã€‚ä»–æå‡ºäº†â€œfirst-class objectâ€æˆ–â€œfirst-class citizenâ€çš„æ¦‚å¿µï¼Œç”¨æ¥æè¿°ç¼–ç¨‹è¯­è¨€ä¸­å¯¹æŸç§å®ä½“ï¼ˆå¦‚å‡½æ•°ã€å¯¹è±¡ã€æ•°å­—ç­‰ï¼‰æ‰€èµ‹äºˆçš„æƒåˆ©æˆ–èƒ½åŠ›ã€‚

åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œå¦‚æœæŸç§å®ä½“æ˜¯â€œä¸€ç­‰å…¬æ°‘â€ï¼Œå®ƒå°±å…·å¤‡ä»¥ä¸‹æƒåˆ©ï¼š

1. **èµ‹å€¼**ï¼šå¯ä»¥èµ‹å€¼ç»™å˜é‡æˆ–å­˜å‚¨åœ¨æ•°æ®ç»“æ„ä¸­ã€‚
2. **ä¼ é€’**ï¼šå¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°æˆ–æ–¹æ³•ã€‚
3. **è¿”å›**ï¼šå¯ä»¥ä½œä¸ºå‡½æ•°æˆ–æ–¹æ³•çš„è¿”å›å€¼ã€‚
4. **åŠ¨æ€åˆ›å»º**ï¼šå¯ä»¥åœ¨ç¨‹åºè¿è¡Œæ—¶åŠ¨æ€åˆ›å»ºã€‚

åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ï¼ŒæŸç§å®ä½“å¦‚æœæ˜¯â€œä¸€ç­‰å…¬æ°‘â€ï¼Œå®ƒåœ¨è¯­è¨€ä¸­äº«æœ‰æœ€å¤§çš„è‡ªç”±å’Œçµæ´»æ€§ï¼Œå¯ä»¥åƒå…¶ä»–åŸºæœ¬æ•°æ®ç±»å‹ï¼ˆå¦‚æ•´æ•°æˆ–å­—ç¬¦ä¸²ï¼‰ä¸€æ ·è¢«æ“ä½œã€‚è¿™ä¸ªæ¯”å–»å½¢è±¡åœ°è¡¨è¾¾äº†åœ¨ç¼–ç¨‹è¯­è¨€ä¸­å¯¹æŸç§å®ä½“çš„é«˜åº¦è‡ªç”±å’Œçµæ´»æ€§ï¼Œè€Œè¿™ç§è‡ªç”±ä½¿å¾—ç¼–ç¨‹è¯­è¨€æ›´åŠ çµæ´»å’Œå¼ºå¤§ã€‚



## Generators 

å½“æ‚¨éœ€è¦å»¶è¿Ÿç”Ÿæˆå€¼åºåˆ—æ—¶ï¼Œè¯·è€ƒè™‘ä½¿ç”¨ç”Ÿæˆå™¨å‡½æ•°ã€‚ Dart å†…ç½®æ”¯æŒä¸¤ç§ç”Ÿæˆå™¨å‡½æ•°ï¼š

- **Synchronous** generator: Returns an [`Iterable`](https://api.dart.cn/stable/dart-core/Iterable-class.html) object.  
  - åŒæ­¥ç”Ÿæˆå™¨ï¼šè¿”å›ä¸€ä¸ª`Iterable`å¯¹è±¡ã€‚
- **Asynchronous** generator: Returns a [`Stream`](https://api.dart.cn/stable/dart-async/Stream-class.html) object.
  - å¼‚æ­¥ç”Ÿæˆå™¨ï¼šè¿”å›ä¸€ä¸ª`Stream`å¯¹è±¡ã€‚

è¦å®ç°åŒæ­¥ç”Ÿæˆå™¨å‡½æ•°ï¼Œè¯·å°†å‡½æ•°ä½“æ ‡è®°ä¸º `sync*` ï¼Œå¹¶ä½¿ç”¨ `yield` è¯­å¥ä¼ é€’å€¼ï¼š

```dart
Iterable<int> naturalsTo(int n) sync* {
  int k = 0;
  while (k < n) yield k++;
}
```

è¦å®ç°å¼‚æ­¥ç”Ÿæˆå™¨å‡½æ•°ï¼Œè¯·å°†å‡½æ•°ä½“æ ‡è®°ä¸º `async*` ï¼Œå¹¶ä½¿ç”¨ `yield` è¯­å¥ä¼ é€’å€¼ï¼š

```dart
Stream<int> asynchronousNaturalsTo(int n) async* {
  int k = 0;
  while (k < n) yield k++;
}
```

å¦‚æœæ‚¨çš„ç”Ÿæˆå™¨æ˜¯é€’å½’çš„ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `yield*` æé«˜å…¶æ€§èƒ½ï¼š

```dart
Iterable<int> naturalsDownFrom(int n) sync* {
  if (n > 0) {
    yield n;
    yield* naturalsDownFrom(n - 1);
  }
}

// å¦‚ä½•è·å–å€¼ 

// 1. main ä¸º asyncï¼Œä½¿ç”¨ toList
void main(List<String> args) async {
	List<int> res = await naturalsDownFrom(10).toList();
	print(res);
}

// 2
void main(List<String> args) async {
  Stream<int> res = naturalsDownFrom(10);
  await res.listen((v) {
    print(v);
  });
}

// 3
void main(List<String> args) async {
  Stream<int> res = naturalsDownFrom(10);
  await res.forEach((v) {
    print(v);
  });
}

// 4
void main(List<String> args) async {
  Stream<int> res = naturalsDownFrom(10);
  await for (int v in res) {
    print(v);
  }
}
```





## External functions

å¤–éƒ¨å‡½æ•°æ˜¯æŒ‡å…¶**å‡½æ•°ä½“ä¸å…¶å£°æ˜åˆ†å¼€å®ç°çš„å‡½æ•°**ã€‚åœ¨å‡½æ•°å£°æ˜ä¹‹å‰åŒ…å« `external` å…³é”®å­—ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```dart
external void someFunc(int i);
```

å¤–éƒ¨å‡½æ•°çš„**å®ç°å¯ä»¥æ¥è‡ªå¦ä¸€ä¸ª Dart åº“ï¼Œæˆ–è€…æ›´å¸¸è§çš„æ˜¯æ¥è‡ªå¦ä¸€ç§è¯­è¨€**ã€‚åœ¨äº’æ“ä½œä¸Šä¸‹æ–‡ä¸­ï¼Œ`external` å¼•å…¥å¤–éƒ¨å‡½æ•°æˆ–å€¼çš„ç±»å‹ä¿¡æ¯ï¼Œä½¿å®ƒä»¬å¯ä»¥åœ¨ Dart ä¸­ä½¿ç”¨ã€‚å®ç°å’Œä½¿ç”¨åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šæ˜¯ç‰¹å®šäºå¹³å°çš„ï¼Œå› æ­¤è¯·æŸ¥çœ‹ C æˆ– JavaScript ç­‰äº’æ“ä½œæ–‡æ¡£ä»¥äº†è§£æ›´å¤šä¿¡æ¯ã€‚

å¤–éƒ¨å‡½æ•°å¯ä»¥æ˜¯é¡¶çº§å‡½æ•°ã€å®ä¾‹æ–¹æ³•ã€getter æˆ– setter æˆ–éé‡å®šå‘æ„é€ å‡½æ•°ã€‚å®ä¾‹å˜é‡ä¹Ÿå¯ä»¥æ˜¯ `external` ï¼Œè¿™ç›¸å½“äºå¤–éƒ¨ getter å’Œï¼ˆå¦‚æœå˜é‡ä¸æ˜¯ `final` ï¼‰å¤–éƒ¨ setterã€‚







# Loops

## For loops

Dart çš„ `for` å¾ªç¯å†…éƒ¨çš„é—­åŒ…æ•è·ç´¢å¼•çš„å€¼ã€‚è¿™é¿å…äº† JavaScript ä¸­å¸¸è§çš„é™·é˜±ã€‚

```dart
var callbacks = [];
for (var i = 0; i < 2; i++) {
  callbacks.add(() => print(i));
}

// output: 0 1
for (final c in callbacks) {
  c();
}
```

æœ‰æ—¶ï¼Œåœ¨è¿­ä»£ `Iterable` ç±»å‹ï¼ˆä¾‹å¦‚ `List` æˆ– `Set` ï¼‰æ—¶ï¼Œæ‚¨å¯èƒ½*ä¸éœ€è¦çŸ¥é“å½“å‰è¿­ä»£è®¡æ•°å™¨*ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¯·ä½¿ç”¨ `for-in` å¾ªç¯æ¥è·å¾—æ›´ç®€æ´çš„ä»£ç ï¼š

```dart
for (final candidate in candidates) {
  candidate.interview();
}
```

è¦å¤„ç†ä» iterable è·å–çš„å€¼ï¼Œæ‚¨è¿˜å¯ä»¥åœ¨ `for-in` å¾ªç¯ä¸­ä½¿ç”¨æ¨¡å¼ï¼š

```dart
for (final Candidate(:name, :yearsExperience) in candidates) {
  print('$name has $yearsExperience of experience.');
}
```

## While and do-while

## Break and continue





# Branches

- `if` statements and elements
- `if-case` statements and elements
- `switch` statements and expressions

## If-case

Dart `if` statements support `case` clauses followed by a [pattern](https://dart.cn/language/patterns)

```dart
if (pair case [int x, int y]) return Point(x, y);
```

## Switch statements 

```dart
switch (command) {
  case 'OPEN':
    executeOpen();
    continue newCase; // Continues executing at the newCase label.

  case 'DENIED': // Empty case falls through.
  case 'CLOSED':
    executeClosed(); // Runs for both DENIED and CLOSED,

  newCase:
  case 'PENDING':
    executeNowClosed(); // Runs for both OPEN and PENDING.
}
```

### Switch expressions

A `switch` *expression* **produces a value** based on the expression body of whichever case matches. You can **use a switch expression wherever Dart allows expressions**, *except* at the start of an expression statement.

```dart
var x = switch (y) { ... };

print(switch (x) { ... });

return switch (x) { ... };
```

```dart
token = switch (charCode) {
  slash || star || plus || minus => operator(charCode),
  comma || semicolon => punctuation(charCode),
  >= digit0 && <= digit9 => number(),
  // DEFAULT
  _ => throw FormatException('Invalid')
};
```

The syntax of a `switch` expression differs from `switch` statement syntax:

- Cases *do not* start with the `case` keyword.
- A case body is a single expression instead of a series of statements.
- Each case must have a body; **there is no implicit fallthrough for empty cases**.
- Case patterns are separated from their bodies using `=>` instead of `:`.
- Cases are separated by `,` (and an optional trailing `,` is allowed).
- Default cases can *only* use `_`, instead of allowing both `default` and `_`.

> Switch expressions require a [language version](https://dart.cn/guides/language/evolution#language-versioning) of at least 3.0.

## Guard clause

è¦åœ¨ `case` å­å¥åè®¾ç½®å¯é€‰çš„ä¿æŠ¤å­å¥ï¼Œè¯·ä½¿ç”¨å…³é”®å­— `when` ã€‚ä¿æŠ¤å­å¥å¯ä»¥è·Ÿåœ¨ `if case` ä»¥åŠ `switch` è¯­å¥å’Œè¡¨è¾¾å¼ä¹‹åã€‚

When the guard clause **evaluates to false**, execution **proceeds to the next case rather than exiting the entire switch**.

```dart
// Switch statement:
switch (something) {
  case somePattern when some || boolean || expression:
    //             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Guard clause.
    body;
}

// Switch expression:
var value = switch (something) {
  somePattern when some || boolean || expression => body,
  //               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Guard clause.
}

// If-case statement:
if (something case somePattern when some || boolean || expression) {
  //                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Guard clause.
  body;
}
```

### 



# Error handling

## Catch

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  buyMoreLlamas();
  // éœ€è¦å¼‚å¸¸å¯¹è±¡æ—¶ä½¿ç”¨ catch
} on Exception catch (e) {
  // Anything else that is an exception
  print('Unknown exception: $e');
} catch (e) {
  // No specified type, handles all
  print('Something really unknown: $e');
}

// æ‚¨å¯ä»¥ä¸º catch() æŒ‡å®šä¸€ä¸ªæˆ–ä¸¤ä¸ªå‚æ•°ã€‚ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æŠ›å‡ºçš„å¼‚å¸¸ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯å †æ ˆè·Ÿè¸ªï¼ˆStackTrace å¯¹è±¡ï¼‰
try {
  // Â·Â·Â·
} on Exception catch (e) {
  print('Exception details:\n $e');
} catch (e, s) {
  print('Exception details:\n $e');
  print('Stack trace:\n $s');
}
```

è¦éƒ¨åˆ†å¤„ç†å¼‚å¸¸ï¼ŒåŒæ—¶å…è®¸å…¶ä¼ æ’­ï¼Œè¯·ä½¿ç”¨ `rethrow` å…³é”®å­—ã€‚

```dart
void misbehave() {
  try {
    dynamic foo = true;
    print(foo++); // Runtime error
  } catch (e) {
    print('misbehave() partially handled ${e.runtimeType}.');
    rethrow; // Allow callers to see the exception.
  }
}
```

## Assert

`assert` çš„ç¬¬ä¸€ä¸ªå‚æ•°å¯ä»¥æ˜¯è§£æä¸ºå¸ƒå°”å€¼çš„ä»»ä½•è¡¨è¾¾å¼ã€‚å¦‚æœè¡¨è¾¾å¼çš„å€¼ä¸º trueï¼Œåˆ™æ–­è¨€æˆåŠŸå¹¶ç»§ç»­æ‰§è¡Œã€‚å¦‚æœä¸º falseï¼Œåˆ™æ–­è¨€å¤±è´¥å¹¶å¼•å‘å¼‚å¸¸ï¼ˆ`AssertionError`ï¼‰ã€‚

è¦å°†æ¶ˆæ¯é™„åŠ åˆ°æ–­è¨€ï¼Œè¯·å°†å­—ç¬¦ä¸²æ·»åŠ ä¸º `assert` çš„ç¬¬äºŒä¸ªå‚æ•°ï¼ˆå¯ä»¥é€‰æ‹©ä½¿ç”¨å°¾éšé€—å·ï¼‰ï¼š

```dart
assert(urlString.startsWith('https'),
    'URL ($urlString) should start with "https".');
```

æ–­è¨€åˆ°åº•ä»€ä¹ˆæ—¶å€™èµ·ä½œç”¨ï¼Ÿè¿™å–å†³äºæ‚¨ä½¿ç”¨çš„å·¥å…·å’Œæ¡†æ¶ï¼š

- Flutter enables assertions in [debug mode. ](https://docs.flutter.cn/testing/debugging#debug-mode-assertions) 
  - Flutter åœ¨è°ƒè¯•æ¨¡å¼ä¸‹å¯ç”¨æ–­è¨€ã€‚
- Development-only tools such as [`webdev serve`](https://dart.cn/tools/webdev#serve) typically enable assertions by default.
  - `webdev serve` ç­‰ä»…ä¾›å¼€å‘çš„å·¥å…·é€šå¸¸é»˜è®¤å¯ç”¨æ–­è¨€ã€‚
- Some tools, such as [`dart run`](https://dart.cn/tools/dart-run) and [`dart compile js`](https://dart.cn/tools/dart-compile#js) support assertions through a command-line flag: `--enable-asserts`.
  - æŸäº›å·¥å…·ï¼Œä¾‹å¦‚ `dart run` å’Œ `dart compile js` æ”¯æŒé€šè¿‡å‘½ä»¤è¡Œæ ‡å¿—è¿›è¡Œæ–­è¨€ï¼š `--enable-asserts` ã€‚

In production code, assertions are ignored, and the arguments to `assert` aren't evaluated.



